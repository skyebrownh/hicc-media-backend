from uuid import UUID, uuid4
from pydantic import ConfigDict
from typing import TYPE_CHECKING
from sqlmodel import SQLModel, Field, Relationship, Column, ForeignKey, CheckConstraint, TIMESTAMP
from datetime import datetime, timezone
from app.utils.helpers import maybe

if TYPE_CHECKING:
    from app.db.models import Schedule, EventType, Team, EventAssignment, EventAssignmentEmbeddedPublic

class EventBase(SQLModel):
    title: str | None = Field(default=None)
    starts_at: datetime = Field(sa_column=Column(TIMESTAMP(timezone=True), index=True))
    ends_at: datetime = Field(sa_column=Column(TIMESTAMP(timezone=True)))
    team_id: UUID | None = Field(default=None, sa_column=Column(ForeignKey("teams.id"), nullable=True))
    event_type_id: UUID = Field(sa_column=Column(ForeignKey("event_types.id"), index=True, nullable=False))
    notes: str | None = Field(default=None)
    is_active: bool = Field(default=True)

class Event(EventBase, table=True):
    __tablename__ = "events"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    schedule_id: UUID = Field(sa_column=Column(ForeignKey("schedules.id", ondelete="CASCADE"), index=True, nullable=False))
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True), onupdate=lambda: datetime.now(timezone.utc))
    )

    # Relationships
    schedule: "Schedule" = Relationship(back_populates="events")
    team: "Team" = Relationship()
    event_type: "EventType" = Relationship()
    event_assignments: list["EventAssignment"] = Relationship(back_populates="event")

    __table_args__ = (
        CheckConstraint("starts_at < ends_at", name="event_check_time_range"),
    )

class EventCreate(EventBase):
    model_config = ConfigDict(extra="forbid")
    # event.id is auto-generated by the DB
    schedule_id: UUID

class EventUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # event.id is used to update the event
    # event.schedule_id is not updatable, delete and recreate if needed
    title: str | None = None
    starts_at: datetime | None = None
    ends_at: datetime | None = None
    team_id: UUID | None = None
    event_type_id: UUID | None = None
    notes: str | None = None
    is_active: bool | None = None

class EventPublic(EventBase):
    id: UUID
    schedule_id: UUID
    # join fields
    schedule_month: int
    schedule_year: int
    schedule_notes: str | None
    schedule_is_active: bool
    team_name: str | None
    team_code: str | None
    team_is_active: bool | None
    event_type_name: str
    event_type_code: str
    event_type_is_active: bool
    
    @classmethod
    def from_objects(
        cls,
        event: "Event",
        schedule: "Schedule",
        event_type: "EventType",
        team: "Team | None" = None,
    ):
        """Create an EventPublic from the related objects."""
        return cls(
            id=event.id,
            schedule_id=event.schedule_id,
            title=event.title,
            starts_at=event.starts_at,
            ends_at=event.ends_at,
            team_id=event.team_id,
            event_type_id=event.event_type_id,
            notes=event.notes,
            is_active=event.is_active,
            schedule_month=schedule.month,
            schedule_year=schedule.year,
            schedule_notes=schedule.notes,
            schedule_is_active=schedule.is_active,
            team_name=maybe(team, "name"),
            team_code=maybe(team, "code"),
            team_is_active=maybe(team, "is_active"),
            event_type_name=event_type.name,
            event_type_code=event_type.code,
            event_type_is_active=event_type.is_active,
        )

class EventWithAssignmentsPublic(SQLModel):
    event: EventPublic
    event_assignments: list["EventAssignmentEmbeddedPublic"]