from uuid import UUID, uuid4
from pydantic import ConfigDict
from sqlmodel import TIMESTAMP, SQLModel, Field, Column, UniqueConstraint, CheckConstraint
from enum import Enum
from sqlalchemy import Enum as SAEnum
from datetime import datetime, timezone

# =============================
# ROLES
# =============================
class RoleBase(SQLModel):
    name: str
    description: str | None = Field(default=None)
    order: int
    is_active: bool = Field(default=True)

class Role(RoleBase, table=True):
    __tablename__ = "roles"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    code: str = Field(index=True, unique=True)
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

class RoleCreate(RoleBase):
    model_config = ConfigDict(extra="forbid")
    # role.id is auto-generated by the DB
    code: str

class RoleUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # role.id is used to update the role
    # role.code is not updatable, delete and recreate if needed
    name: str | None = None
    description: str | None = None
    order: int | None = None
    is_active: bool | None = None

# =============================
# PROFICIENCY LEVELS
# =============================
class ProficiencyLevelBase(SQLModel):
    name: str
    rank: int | None = Field(default=None)
    is_active: bool = Field(default=True)
    is_assignable: bool = Field(default=False)

class ProficiencyLevel(ProficiencyLevelBase, table=True):
    __tablename__ = "proficiency_levels"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    code: str = Field(index=True, unique=True)
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

class ProficiencyLevelCreate(ProficiencyLevelBase):
    model_config = ConfigDict(extra="forbid")
    # proficiency_level.id is auto-generated by the DB
    code: str

class ProficiencyLevelUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # proficiency_level.id is used to update the proficiency level
    # proficiency_level.code is not updatable, delete and recreate if needed
    name: str | None = None
    rank: int | None = None
    is_active: bool | None = None
    is_assignable: bool | None = None

# =============================
# EVENT TYPES
# =============================
class EventTypeBase(SQLModel):
    name: str
    is_active: bool = Field(default=True)

class EventType(EventTypeBase, table=True):
    __tablename__ = "event_types"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    code: str = Field(index=True, unique=True)
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

class EventTypeCreate(EventTypeBase):
    model_config = ConfigDict(extra="forbid")
    # schedule_date_type.id is auto-generated by the DB
    code: str

class EventTypeUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # schedule_date_type.id is used to update the schedule date type
    # schedule_date_type.code is not updatable, delete and recreate if needed
    name: str | None = None
    is_active: bool | None = None

# =============================
# TEAMS
# =============================
class TeamBase(SQLModel):
    name: str
    is_active: bool = Field(default=True)

class Team(TeamBase, table=True):
    __tablename__ = "teams"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    code: str = Field(index=True, unique=True)
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

class TeamCreate(TeamBase):
    model_config = ConfigDict(extra="forbid")
    # team.id is auto-generated by the DB
    code: str

class TeamUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # team.id is used to update the team
    name: str | None = None
    is_active: bool | None = None

# =============================
# USERS
# =============================
class UserBase(SQLModel):
    first_name: str
    last_name: str
    email: str | None = Field(default=None)
    phone: str
    is_active: bool = Field(default=True)

class User(UserBase, table=True):
    __tablename__ = "users"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

class UserCreate(UserBase):
    model_config = ConfigDict(extra="forbid")
    # user.id is auto-generated by the DB

class UserUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # user.id is used to update the user
    first_name: str | None = None
    last_name: str | None = None
    email: str | None = None
    phone: str | None = None
    is_active: bool | None = None

# =============================
# TEAM USERS
# =============================
class TeamUserBase(SQLModel):
    is_active: bool = Field(default=True)

class TeamUser(TeamUserBase, table=True):
    __tablename__ = "team_users"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    team_id: UUID = Field(index=True, foreign_key="teams.id")
    user_id: UUID = Field(index=True, foreign_key="users.id")
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

    __table_args__ = (
        UniqueConstraint("team_id", "user_id", name="team_user_ukey"),
    )

class TeamUserCreate(TeamUserBase):
    model_config = ConfigDict(extra="forbid")
    # team_user.id is auto-generated by the DB
    team_id: UUID
    user_id: UUID

class TeamUserUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # team_user.team_id + team_user.user_id is used to update the team user
    is_active: bool | None = None

class TeamUserPublic(TeamUserBase):
    id: UUID
    team_id: UUID
    user_id: UUID
    # join fields
    team_name: str
    team_code: str
    team_is_active: bool
    user_first_name: str
    user_last_name: str
    user_email: str | None
    user_phone: str
    user_is_active: bool

# =============================
# USER ROLES
# =============================
class UserRoleBase(SQLModel):
    proficiency_level_id: UUID = Field(index=True, foreign_key="proficiency_levels.id")

class UserRole(UserRoleBase, table=True):
    __tablename__ = "user_roles"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(index=True, foreign_key="users.id")
    role_id: UUID = Field(index=True, foreign_key="roles.id")
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

    __table_args__ = (
        UniqueConstraint("user_id", "role_id", name="user_role_ukey"),
    )

class UserRoleCreate(UserRoleBase):
    model_config = ConfigDict(extra="forbid")
    # user_role.id is auto-generated by the DB
    user_id: UUID
    role_id: UUID

class UserRoleUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # user_role.user_id + user_role.role_id is used to update the user role
    proficiency_level_id: UUID | None = None

class UserRolePublic(UserRoleBase):
    id: UUID
    user_id: UUID
    role_id: UUID
    proficiency_level_id: UUID
    # join fields
    user_first_name: str
    user_last_name: str
    user_email: str | None
    user_phone: str
    user_is_active: bool
    role_name: str
    role_description: str | None
    role_order: int
    role_is_active: bool
    role_code: str
    proficiency_level_name: str
    proficiency_level_rank: int | None
    proficiency_level_is_assignable: bool
    proficiency_level_is_active: bool
    proficiency_level_code: str

# =============================
# SCHEDULES
# =============================
class ScheduleBase(SQLModel):
    is_active: bool = Field(default=True)
    notes: str | None = Field(default=None)

class Schedule(ScheduleBase, table=True):
    __tablename__ = "schedules"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    month: int
    year: int
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

    __table_args__ = (
        CheckConstraint("month >= 1 AND month <= 12", name="schedule_check_month"),
    )

class ScheduleCreate(ScheduleBase):
    model_config = ConfigDict(extra="forbid")
    # schedule.id is auto-generated by the DB
    month: int
    year: int

class ScheduleUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # schedule.id is used to update the schedule
    is_active: bool | None = None
    notes: str | None = None

# =============================
# EVENTS
# =============================
class EventBase(SQLModel):
    title: str | None = Field(default=None)
    starts_at: datetime = Field(sa_column=Column(TIMESTAMP(timezone=True), index=True))
    ends_at: datetime = Field(sa_column=Column(TIMESTAMP(timezone=True)))
    team_id: UUID | None = Field(default=None, foreign_key="teams.id")
    event_type_id: UUID = Field(index=True, foreign_key="event_types.id")
    notes: str | None = Field(default=None)
    is_active: bool = Field(default=True)

class Event(EventBase, table=True):
    __tablename__ = "events"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    schedule_id: UUID = Field(index=True, foreign_key="schedules.id")
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

    __table_args__ = (
        CheckConstraint("starts_at < ends_at", name="event_check_time_range"),
    )

class EventCreate(EventBase):
    model_config = ConfigDict(extra="forbid")
    # event.id is auto-generated by the DB
    schedule_id: UUID

class EventUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # event.id is used to update the event
    # event.schedule_id is not updatable, delete and recreate if needed
    title: str | None = None
    starts_at: datetime | None = None
    ends_at: datetime | None = None
    team_id: UUID | None = None
    event_type_id: UUID | None = None
    notes: str | None = None
    is_active: bool | None = None

class EventPublic(EventBase):
    id: UUID
    schedule_id: UUID
    # join fields
    schedule_month: int
    schedule_year: int
    schedule_notes: str | None
    schedule_is_active: bool
    team_name: str | None
    team_code: str | None
    team_is_active: bool | None
    event_type_name: str
    event_type_code: str
    event_type_is_active: bool

# =============================
# EVENT ASSIGNMENTS
# =============================
class RequirementLevel(str, Enum):
    REQUIRED = "required"
    PREFERRED = "preferred"
    OPTIONAL = "optional"

class EventAssignmentBase(SQLModel):
    # is_applicable: bool - whether the role is applicable to the event
    is_applicable: bool = Field(default=True)
    # requirement_level: RequirementLevel - importance to fill the role for the event
    requirement_level: RequirementLevel = Field(default=RequirementLevel.REQUIRED, sa_column=Column(SAEnum(RequirementLevel, name="requirement_level")))
    assigned_user_id: UUID | None = Field(default=None, foreign_key="users.id", index=True)
    is_active: bool = Field(default=True)

class EventAssignment(EventAssignmentBase, table=True):
    __tablename__ = "event_assignments"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    event_id: UUID = Field(index=True, foreign_key="events.id")
    role_id: UUID = Field(index=True, foreign_key="roles.id")
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

    __table_args__ = (
        UniqueConstraint("event_id", "role_id", name="event_assignment_ukey"),
    )

class EventAssignmentCreate(EventAssignmentBase):
    model_config = ConfigDict(extra="forbid")
    # event_assignment.id is auto-generated by the DB
    event_id: UUID
    role_id: UUID

class EventAssignmentUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # event_assignment.id is used to update the event assignment
    # event_assignment.event_id is not updatable, delete and recreate if needed
    requirement_level: RequirementLevel | None = None
    assigned_user_id: UUID | None = None
    is_active: bool | None = None

class EventAssignmentPublic(EventAssignmentBase):
    id: UUID
    event_id: UUID
    # join fields
    event_title: str | None
    event_starts_at: datetime
    event_ends_at: datetime
    event_notes: str | None
    event_is_active: bool
    event_team_id: UUID | None
    event_team_name: str | None
    event_team_code: str | None
    event_team_is_active: bool | None
    event_type_id: UUID
    event_type_name: str
    event_type_code: str
    event_type_is_active: bool
    role_name: str
    role_description: str | None
    role_order: int
    role_code: str
    role_is_active: bool
    assigned_user_first_name: str | None
    assigned_user_last_name: str | None
    assigned_user_email: str | None
    assigned_user_phone: str | None
    assigned_user_is_active: bool | None
    # from user_roles table
    proficiency_level_id: UUID
    proficiency_level_name: str
    proficiency_level_rank: int | None
    proficiency_level_is_assignable: bool
    proficiency_level_is_active: bool | None
    proficiency_level_code: str

# =============================
# USER UNAVAILABLE PERIODS
# =============================
class UserUnavailablePeriodBase(SQLModel):
    starts_at: datetime = Field(sa_column=Column(TIMESTAMP(timezone=True), index=True))
    ends_at: datetime = Field(sa_column=Column(TIMESTAMP(timezone=True)))

class UserUnavailablePeriod(UserUnavailablePeriodBase, table=True):
    __tablename__ = "user_unavailable_periods"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(index=True, foreign_key="users.id")
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column=Column(TIMESTAMP(timezone=True))
    )

    __table_args__ = (
        CheckConstraint("starts_at < ends_at", name="user_unavailable_period_check_time_range"),
    )

class UserUnavailablePeriodCreate(UserUnavailablePeriodBase):
    model_config = ConfigDict(extra="forbid")
    # user_unavailable_period.id is auto-generated by the DB
    user_id: UUID

class UserUnavailablePeriodUpdate(SQLModel):
    model_config = ConfigDict(extra="forbid")
    # user_id is not updatable, delete and recreate if needed
    starts_at: datetime | None = None
    ends_at: datetime | None = None

class UserUnavailablePeriodPublic(UserUnavailablePeriodBase):
    id: UUID
    user_id: UUID
    # join fields
    user_first_name: str
    user_last_name: str
    user_email: str | None
    user_phone: str
    user_is_active: bool
